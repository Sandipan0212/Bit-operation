# -*- coding: utf-8 -*-
"""Bit.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1peTWEeuZOE20coGed0OKbifkRWA6MJ3P
"""

#right shift
x = 13
print(bin(x))
print(bin(x>>2))

#left shift
x = 13
print(bin(x))
print(bin(x<<2))

#alternate of left shift
x = 13
x = x * (2**2)
print(bin(x))

#not operator
X = 13
print(bin(x))
~X
bin(~X)

#check kth bit is 0 or 1
def check(N,i):
  mask = 1<<i
  if N & mask > 0:
    return 1
  else:
    return 0

check(13,2)

#set ith bit to 1
def set(N,i):
  mask = 1<<i
  N = N | mask
  return N

set(13,1)

#reset ith bit to 0
def set(N,i):
  mask = ~(1<<i)
  N = N & mask
  return N

set(15,1)

#using above two method try to toggle ith bit
def toggle(N,i):
  mask1 = 1<<i
  mask2 = ~(1<<i)
  if N & mask1 > 0:
    return N & mask2
  else:
    return N | mask1

#print(mask1)
#print(mask2)
toggle(13,1)

#toggle using XOR
def toggle(N,i):
  mask = 1<<i
  return N^mask

toggle(13,1)

#change the ith bit to given 1 or 0
def change(N,i,value):
  mask1 = ~(1<<i)
  res = N & mask1 ###making ith bit to 0
  mask2 = value<<i
  res = res | mask2  ###adding 0 or 1 to ith bit
  return res

change(13,1,1)

#set last i bits to 0
def change(N,i):
  mask = (~0)<<i
  return N & mask

change(13,3)

#set last i bits to 1
def change(N,i):
  mask = (1<<i)-1
  return N | mask

change(8,3)

#reset i th to j th bit in a number
def resetitoj(N,i,j):
  mask1 = (~0)<<j+1
  mask2 = (1<<i)-1
  mask3 = mask1 | mask2
  return N & mask3

print(bin(445))
print(bin(resetitoj(445,3,5)))

#now to set ith to jth bit in a number
def setitoj(N,i,j):
  k = j-i+1
  mask = (1<<k) - 1
  mask1 = mask << i
  return N | mask1

print(bin(449))
print(bin(setitoj(449,1,5)))
#print(bin((1<<5) - 1))

#check power of two
def checkpow2(N):
  if N & (N-1) == 0:
    return f"{N} is pow of 2"
  else:
    return f"{N} is not pow of 2"

checkpow2(15)

#replace a number with a new number between i to j bits
def replace(N,M,i,j):
  mask = (~0)<<j+1
  mask1 = (1<<i)-1
  mask2 = mask | mask1
  res = N & mask2
  res = res | (M<<i)
  return res

replace(73,5,2,4)

#count number of bits
def count(N):
  ans = 0
  while N>0:
    N = N >> 1
    ans = ans +1
  return ans

count(8)

#reset first i bits
def resetfirst(N,i):
  count = 0
  num = N
  while num>0:
    num = num >> 1
    count = count +1
  mask = (1<<(count-i))-1
  N = N & mask
  return N

#mask = bin((1<<(5))-1)
#print(mask)
#print(bin(400))
print((resetfirst(171,2)))

#set first i bits
def setfirst(N,i):
  count = 0
  num = N
  while num>0:
    num = num >> 1
    count = count +1

  mask = ((1<<i)-1)<<(count-i)
  N = N | mask
  return N

setfirst(171,4)

#count no of set bts
def count(N):
  c = 0
  while N > 0:
    ans = N & 1
    c = c + ans
    N = N >> 1
  return c

count(8)

#position of first set bit operator from right side
def check(N):
  if N == 0:
    return -1
  count = 0
  while N > 0:
    res = N & 1
    if res == 1:
      return count
    else:
      N = N >> 1
      count = count + 1

check(8)

print(chr(66))
print(ord("b"))
i=1
base=64
print(chr(i+base))

#swap twwo bits in a number
def swap (N,i,j):
  bit1 = (N >> i) & 1
  bit2 = (N>>j) & 1
  x = bit1 ^ bit2
  # Put the xor bit back to their original positions
  x = (x << i) | (x << j)
  return N ^ x


print(bin(399))
print(bin(swap(399,1,5)))

#swap nibbles in a byte
def swapNibbles(N) :

    # Step 1
    right = (N & 0b00001111)

    # Step 3
    right= (right<<4)

    # Step 2
    left = (N & 0b11110000)

    # Step 4
    left = (left>>4)

    # Step 5
    return (right | left)

print(bin(swapNibbles(15)))

#num of bits to be changed to convert n into m
def function(N, M):
  res = N ^ M
  count = 0
  while res > 0:
    a = res & 1
    count = count + a
    res = res >> 1
  return count

function(8,7)